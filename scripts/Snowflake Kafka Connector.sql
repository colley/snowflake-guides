
-- 1. 创建专用角色（最佳实践）
CREATE OR REPLACE ROLE KAFKA_ROLE;

CREATE DATABASE KAFKA_DB;
CREATE USER kafka_user
  PASSWORD = ''  -- 不设密码
  RSA_PUBLIC_KEY ='MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAsLdQAxpPtao+uMS7xO2dl+9rHMFdLk8Ecw5mZhRtIZHSvmiBEKa777uJS2W6nN4n1OyflQ8l6lIjIpKqkQ1Ch8J5qUHmwiwQkByb/INtTa8d4q/PnYvzPmW+GuO6RxI1PUif3jaDsLcQBGb2T5KWfNgnOvVeHm8vBfVuKIl4YnoyvYZ5c064tJ4+7avhzur3nNfsHS/OFvPZIVQ/V5gG2JjkuoCAhvdFpIf2RiOVZxhgKj1CdP+OShpDvK2J9M/jPvMuxkhgxxy0hQHl8pqtQ7RFgdY4loS1fNbluaOAC6kvpphoRGQbvPhvWQ0AglLqUxjOuNel9q0A7sMDpy/fQwIDAQAB'
  DEFAULT_ROLE = KAFKA_ROLE
  DEFAULT_WAREHOUSE = MY_WH;



DESCRIBE USER KAFKA_USER;

SELECT CURRENT_REGION();

-- 2. 将数据库所有权转移给该角色（确保它能管理所有对象）
GRANT OWNERSHIP ON DATABASE KAFKA_DB TO ROLE KAFKA_ROLE COPY CURRENT GRANTS;


DESC USER kafka_user;


-- 仓库
GRANT USAGE ON WAREHOUSE MY_WH TO ROLE KAFKA_ROLE;

-- 数据库
GRANT USAGE ON DATABASE KAFKA_DB TO ROLE KAFKA_ROLE;

-- Schema（关键！）
GRANT USAGE ON SCHEMA KAFKA_DB.PUBLIC TO ROLE KAFKA_ROLE;
GRANT CREATE TABLE ON SCHEMA KAFKA_DB.PUBLIC TO ROLE KAFKA_ROLE;
GRANT CREATE STAGE ON SCHEMA KAFKA_DB.PUBLIC TO ROLE KAFKA_ROLE;
GRANT CREATE PIPE ON SCHEMA KAFKA_DB.PUBLIC TO ROLE KAFKA_ROLE;  -- ⚠️ 新增这一行！


USE ROLE KAFKA_ROLE;

-- 授予 ACCOUNTADMIN 访问权限
GRANT USAGE ON DATABASE KAFKA_DB TO ROLE ACCOUNTADMIN;
GRANT USAGE ON SCHEMA KAFKA_DB.PUBLIC TO ROLE ACCOUNTADMIN;

-- （可选）授予 SELECT 权限（虽然 USAGE + ownership 通常足够）
GRANT SELECT ON TABLE KAFKA_DB.PUBLIC.TRACE_DATA TO ROLE ACCOUNTADMIN;

SELECT CURRENT_USER(), CURRENT_ROLE();

-- 切换到 SECURITYADMIN（通常 ACCOUNTADMIN 有这个权限）
USE ROLE SECURITYADMIN;

-- 将 KAFKA_ROLE 授予你的用户（替换为实际用户名）
GRANT ROLE KAFKA_ROLE TO USER COLLEY;

select * from trace_data limit 1;

 USE DATABASE KAFKA_DB;
   USE ROLE KAFKA_ROLE;

CREATE SCHEMA IF NOT EXISTS harmonized;





SELECT
    RECORD_CONTENT:chamberId::INT AS chamber_id,
    AVG(
        TRY_TO_NUMBER(RECORD_CONTENT:traceParams:H_L_Ld::STRING)
    ) AS avg_h_l_ld
FROM KAFKA_DB.PUBLIC.TRACE_DATA
WHERE
    RECORD_CONTENT:chamberId IS NOT NULL
    AND RECORD_CONTENT:traceParams:H_L_Ld IS NOT NULL
GROUP BY
    RECORD_CONTENT:chamberId::INT
ORDER BY
    chamber_id;


    USE DATABASE KAFKA_DB;
   USE ROLE KAFKA_ROLE;

    CREATE OR REPLACE TABLE sample_product_data (id INT, parent_id INT, category_id INT, name VARCHAR, serial_number VARCHAR, key INT, "3rd" INT, amount NUMBER(12, 2), quantity INT, product_date DATE);
INSERT INTO sample_product_data VALUES
    (1, 0, 5, 'Product 1', 'prod-1', 1, 10, 1.00, 15, TO_DATE('2021.01.01', 'YYYY.MM.DD')),
    (2, 1, 5, 'Product 1A', 'prod-1-A', 1, 20, 2.00, 30, TO_DATE('2021.02.01', 'YYYY.MM.DD')),
    (3, 1, 5, 'Product 1B', 'prod-1-B', 1, 30, 3.00, 45, TO_DATE('2021.03.01', 'YYYY.MM.DD')),
    (4, 0, 10, 'Product 2', 'prod-2', 2, 40, 4.00, 60, TO_DATE('2021.04.01', 'YYYY.MM.DD')),
    (5, 4, 10, 'Product 2A', 'prod-2-A', 2, 50, 5.00, 75, TO_DATE('2021.05.01', 'YYYY.MM.DD')),
    (6, 4, 10, 'Product 2B', 'prod-2-B', 2, 60, 6.00, 90, TO_DATE('2021.06.01', 'YYYY.MM.DD')),
    (7, 0, 20, 'Product 3', 'prod-3', 3, 70, 7.00, 105, TO_DATE('2021.07.01', 'YYYY.MM.DD')),
    (8, 7, 20, 'Product 3A', 'prod-3-A', 3, 80, 7.25, 120, TO_DATE('2021.08.01', 'YYYY.MM.DD')),
    (9, 7, 20, 'Product 3B', 'prod-3-B', 3, 90, 7.50, 135, TO_DATE('2021.09.01', 'YYYY.MM.DD')),
    (10, 0, 50, 'Product 4', 'prod-4', 4, 100, 7.75, 150, TO_DATE('2021.10.01', 'YYYY.MM.DD')),
    (11, 10, 50, 'Product 4A', 'prod-4-A', 4, 100, 8.00, 165, TO_DATE('2021.11.01', 'YYYY.MM.DD')),
    (12, 10, 50, 'Product 4B', 'prod-4-B', 4, 100, 8.50, 180, TO_DATE('2021.12.01', 'YYYY.MM.DD'));




CREATE OR REPLACE VIEW harmonized.TRACE_DATA_FLATTENED AS
SELECT
    RECORD_CONTENT:chamberId::INT        AS CHAMBER_ID,
    RECORD_CONTENT:contextParams         AS CONTEXT_PARAMS,
    RECORD_CONTENT:traceParams           AS TRACE_PARAMS,
    RECORD_CONTENT:groupId::INT          AS GROUP_ID,
    RECORD_CONTENT:createTime::BIGINT    AS CREATE_TIME_MS,
    RECORD_CONTENT:traceTime::BIGINT     AS TRACE_TIME_MS,

    -- 转换为带毫秒的时间戳（TIMESTAMP_TZ 类型，显示为 2025-09-17 05:20:37.287）
    TO_TIMESTAMP_LTZ(RECORD_CONTENT:traceTime::BIGINT / 1000)  AS TRACE_TIME,
    TO_TIMESTAMP_LTZ(RECORD_CONTENT:createTime::BIGINT / 1000) AS CREATE_TIME
FROM KAFKA_DB.PUBLIC.TRACE_DATA;

select * from harmonized.TRACE_DATA_FLATTENED limit 100;


GRANT USAGE ON DATABASE SNOWFLAKE TO ROLE KAFKA_ROLE;
GRANT USAGE ON SCHEMA SNOWFLAKE.ML TO ROLE KAFKA_ROLE;

SELECT
    TS,
    VALUE,
    IS_ANOMALY,
    SCORE,
    EXPECTED_VALUE
FROM TABLE(
    SNOWFLAKE.ML.ANOMALY_DETECTION(
        INPUT_DATA => (
            SELECT
                TRACE_TIME AS TS,
                TRY_CAST(TRACE_PARAMS:H_L_Ld::STRING AS NUMBER) AS VALUE
            FROM TRACE_DATA_FLATTENED
            WHERE TRACE_PARAMS:H_L_Ld IS NOT NULL
              AND TRACE_TIME IS NOT NULL
            ORDER BY TRACE_TIME
        ),
        TIMESTAMP_COLNAME => 'TS',
        VALUE_COLNAME => 'VALUE',
        DETECTION_METHOD => 'adaptive'
    )
)
WHERE IS_ANOMALY = TRUE
ORDER BY TS DESC;
